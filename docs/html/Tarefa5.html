<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tarefa5</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa5</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Module responsible for the behaviour of the ghosts.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:isGhostHere">isGhostHere</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Bool</li><li class="src short"><a href="#v:getGhostType">getGhostType</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; Int -&gt; Int</li><li class="src short"><a href="#v:getPacmanLocation">getPacmanLocation</a> :: [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:getNeighbourDistances">getNeighbourDistances</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Player" title="Types">Player</a>] -&gt; [Int]</li><li class="src short"><a href="#v:filterIndices">filterIndices</a> :: Int -&gt; (a -&gt; Bool) -&gt; [a] -&gt; [Int]</li><li class="src short"><a href="#v:hash-39-">hash'</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int</li><li class="src short"><a href="#v:show-39-">show'</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; String</li><li class="src short"><a href="#v:rand-39-">rand'</a> :: Int -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; Int</li><li class="src short"><a href="#v:getLongestDirection">getLongestDirection</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:getShortestDirection">getShortestDirection</a> :: <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></li><li class="src short"><a href="#v:getAdvancedTarget">getAdvancedTarget</a> :: Int -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:chaseMode">chaseMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:scatterMode">scatterMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; Int -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Play" title="Types">Play</a></li><li class="src short"><a href="#v:newst">newst</a> :: [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="Types.html#t:State" title="Types">State</a></li><li class="src short"><a href="#v:chooseMode">chooseMode</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>] -&gt; <a href="Types.html#t:Player" title="Types">Player</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li><li class="src short"><a href="#v:ghostPlay-39-">ghostPlay'</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li><li class="src short"><a href="#v:ghostPlay">ghostPlay</a> :: <a href="Types.html#t:State" title="Types">State</a> -&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:isGhostHere" class="def">isGhostHere</a> <a href="#v:isGhostHere" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Types.html#t:Player" title="Types">Player</a>]</td><td class="doc"><p>the list of players (not necessarily ghosts)</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the specified coordinates</p></td></tr><tr><td class="src">-&gt; Bool</td><td class="doc"><p>wether any ghost from the list is at the coordinates</p></td></tr></table></div><div class="doc"><p>Given a list of players, this function returns wether some
   of the ghosts within that list are at the specified coordinates.</p></div></div><div class="top"><p class="src"><a id="v:getGhostType" class="def">getGhostType</a> <a href="#v:getGhostType" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Types.html#t:Player" title="Types">Player</a>]</td><td class="doc"><p>The list of players (ghosts or otherwise)</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The id of the specified ghost</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The type of the ghost (1 or 2)</p></td></tr></table></div><div class="doc"><p>Given the list of players, returns the type (1 or 2)
   of the specified ghost (given by id)</p><p>Type 1 is direct chase, where the ghost will follow the shortest path towards pacman</p><p>Type 2 is advanced chase, where the ghost follows the shortest path to the position
   4 pieces ahead of pacman, and only then enters direct chase</p></div></div><div class="top"><p class="src"><a id="v:getPacmanLocation" class="def">getPacmanLocation</a> <a href="#v:getPacmanLocation" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Types.html#t:Player" title="Types">Player</a>]</td><td class="doc"><p>The list of players</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The pacman's coordinates</p></td></tr></table></div><div class="doc"><p>Returns the Location of the pacman</p><p>It assumes there is only one pacman player, meaning it will return the first value it finds.
 It also supposes the player exists in the first place, meaning it is not defined if there is no pacman.</p><h2><em>Example</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>getPacmanLocation [(Pacman (PacState (0, (1,1), 2.0, U, 1,1) 2.0 Closed Mega)), (Ghost (GhoState (1,(2,1), 2.5, L,2,2) Dead))]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,1)
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:getNeighbourDistances" class="def">getNeighbourDistances</a> <a href="#v:getNeighbourDistances" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The given coordinates</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>All the distances</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The coordinates of the target</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Player" title="Types">Player</a>]</td><td class="doc"><p>The list of players</p></td></tr><tr><td class="src">-&gt; [Int]</td><td class="doc"><p>The resulting list.</p></td></tr></table></div><div class="doc"><p>Given some coordinates, all the distances between every two points, and a target, returns the distances 
   from the neighbouring cells and the cell itself to the target that do not contain a ghost, i.e, given a set of coordinates (y, x), it returns
   the distance from the squares (y - 1, x), (y + 1, x), (y, x - 1), (y, x + 1) and (y, x), in that order,
   as long as no ghost is contained in them.</p><h2><em>Note</em></h2><p>If any of the neighbouring cells is a wall (meaning it is unreachable) or has a ghost,
   that value is instead replaced by -1 in the final list.</p></div></div><div class="top"><p class="src"><a id="v:filterIndices" class="def">filterIndices</a> <a href="#v:filterIndices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>The index of the first element</p></td></tr><tr><td class="src">-&gt; (a -&gt; Bool)</td><td class="doc"><p>The filtering condition</p></td></tr><tr><td class="src">-&gt; [a]</td><td class="doc"><p>The given list</p></td></tr><tr><td class="src">-&gt; [Int]</td><td class="doc"><p>The resulting list of indices</p></td></tr></table></div><div class="doc"><p>Given the index of the first element, a filter and a list, this function
   returns a list containing the indices of the elements that satisfy said filter
   (ordered in ascending order)</p></div></div><div class="top"><p class="src"><a id="v:hash-39-" class="def">hash'</a> <a href="#v:hash-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>the state</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>the hash</p></td></tr></table></div><div class="doc"><p>Calculates the hash of a State by casting it
   to a String and then calculating its hash (Data.Hashable)</p></div></div><div class="top"><p class="src"><a id="v:show-39-" class="def">show'</a> <a href="#v:show-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>the state</p></td></tr><tr><td class="src">-&gt; String</td><td class="doc"><p>the resulting string</p></td></tr></table></div><div class="doc"><p>Casts a State to a String. Used by hash'</p></div></div><div class="top"><p class="src"><a id="v:rand-39-" class="def">rand'</a> <a href="#v:rand-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p><em>n</em></p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>the state</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>the pseudo-random number from 0 to <em>n</em></p></td></tr></table></div><div class="doc"><p>Given <em>n</em>, this function calculates a pseudo-random number from 0 to <em>n</em> using a state</p></div></div><div class="top"><p class="src"><a id="v:getLongestDirection" class="def">getLongestDirection</a> <a href="#v:getLongestDirection" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The coordinates of the given ghost</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The map representing the distances</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The target the ghost is trying to escape</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The state</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></td><td class="doc"><p>The optimal orientation for the ghost, i.e, the direction which escapes the pacman most optimally</p></td></tr></table></div><div class="doc"><p>Given the coordinates of a ghost, and a map representing the distances between every two points
   of the maze, returns which orientation should the ghost be in in order to escape the target most optimally, i.e, the furthest away from it
   If two or more maximum distances are found, a pseudo-random one based on the hash of the state is returned.</p><h2><em>Note</em></h2><p>This function is greedy. If caught in a dead end, the ghost will not try to escape
   since that would cause a local decrease in the distance to the target.</p></div></div><div class="top"><p class="src"><a id="v:getShortestDirection" class="def">getShortestDirection</a> <a href="#v:getShortestDirection" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The coordinates of the given ghost</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The map representing the distances</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>The coordinates of the target</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The state</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Orientation" title="Types">Orientation</a></td><td class="doc"><p>The optimal orientation for the ghost, i.e, the direction which leads to the pacman the quickest</p></td></tr></table></div><div class="doc"><p>Given the coordinates of a ghost, a target, and a map representing the distances between every two points
   of the maze, returns which orientation should the ghost be in in order to get to the target in the shortest possible distance.
   If two or more minimum distances are found, a pseudo-random one based on the hash of the state is returned.</p></div></div><div class="top"><p class="src"><a id="v:getAdvancedTarget" class="def">getAdvancedTarget</a> <a href="#v:getAdvancedTarget" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>the specified number of moves</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the maze where the player moves</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Player" title="Types">Player</a></td><td class="doc"><p>the player</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the coordinates where he lands</p></td></tr></table></div><div class="doc"><p>For a certain player, returns the position he would land in
   were he to take the specified number of steps
   (assuming collisions with walls)</p></div></div><div class="top"><p class="src"><a id="v:chaseMode" class="def">chaseMode</a> <a href="#v:chaseMode" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The given state</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The ghost's id</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The <code><a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></code> object</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Play" title="Types">Play</a></td><td class="doc"><p>The ghost's move</p></td></tr></table></div><div class="doc"><p>Given a state, and the id of an <code><a href="Types.html#v:Alive" title="Types">Alive</a></code> ghost, returns the its move</p><h2><em>Note</em></h2><p>It is not defined for <code><a href="Types.html#v:Dead" title="Types">Dead</a></code> ghosts</p></div></div><div class="top"><p class="src"><a id="v:scatterMode" class="def">scatterMode</a> <a href="#v:scatterMode" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The given state</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The ghost's id</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The <code><a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></code> object</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Play" title="Types">Play</a></td><td class="doc"><p>The ghost's move</p></td></tr></table></div><div class="doc"><p>Given a state, and the id of a <code><a href="Types.html#v:Dead" title="Types">Dead</a></code> ghost, returns the its move</p><h2><em>Note</em></h2><p>It is not defined for <code><a href="Types.html#v:Alive" title="Types">Alive</a></code> ghosts</p></div></div><div class="top"><p class="src"><a id="v:newst" class="def">newst</a> <a href="#v:newst" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Types.html#t:Play" title="Types">Play</a>]</td><td class="doc"><p>The list of moves</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The original state</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The resulting state</p></td></tr></table></div><div class="doc"><p>Returns the state were the players to move in the specified directions</p></div></div><div class="top"><p class="src"><a id="v:chooseMode" class="def">chooseMode</a> <a href="#v:chooseMode" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The original state</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The <code><a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></code> object</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</td><td class="doc"><p>The list of moves already calculated</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Player" title="Types">Player</a></td><td class="doc"><p>The given player</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</td><td class="doc"><p>The resulting list of moves</p></td></tr></table></div><div class="doc"><p>For the given player, chooses the mode they are to move in and stores their move.
   The moves of previous players are taken into account to decide the moves of the current player.</p></div></div><div class="top"><p class="src"><a id="v:ghostPlay-39-" class="def">ghostPlay'</a> <a href="#v:ghostPlay-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The given state</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>The <code><a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></code> object</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</td><td class="doc"><p>The resulting list of moves</p></td></tr></table></div><div class="doc"><p>Given a state, and a <code><a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></code>, returns the list of moves for each ghost,
   in the order they appear in the players list</p></div></div><div class="top"><p class="src"><a id="v:ghostPlay" class="def">ghostPlay</a> <a href="#v:ghostPlay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:State" title="Types">State</a></td><td class="doc"><p>The given state</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Play" title="Types">Play</a>]</td><td class="doc"><p>The resulting list of moves</p></td></tr></table></div><div class="doc"><p>Given a state, returns the list of moves for each ghost,
   in the order they appear in the players list</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>