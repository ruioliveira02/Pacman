<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>LazyBFS</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">LazyBFS</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Module used for calculating the distances between squares of the maze. Used by <a href="Tarefa5.html">Tarefa5</a>
    to compute the moves the ghosts should make.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:maxValue">maxValue</a> :: Int</li><li class="src short"><span class="keyword">type</span> <a href="#t:Memoization">Memoization</a> = Map <a href="Types.html#t:Coords" title="Types">Coords</a> ([Set <a href="Types.html#t:Coords" title="Types">Coords</a>], Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int))</li><li class="src short"><a href="#v:distance">distance</a> :: <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Int</li><li class="src short"><a href="#v:mazeSize">mazeSize</a> :: <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></li><li class="src short"><a href="#v:getMemory">getMemory</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></li><li class="src short"><a href="#v:mapper">mapper</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; a -&gt; ([Set <a href="Types.html#t:Coords" title="Types">Coords</a>], Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int))</li><li class="src short"><a href="#v:coords">coords</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int)</li><li class="src short"><a href="#v:atDists">atDists</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [Set <a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:atDists-39-">atDists'</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Set <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; Set <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [Set <a href="Types.html#t:Coords" title="Types">Coords</a>]</li><li class="src short"><a href="#v:getNeighbours">getNeighbours</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Coords" title="Types">Coords</a> -&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:maxValue" class="def">maxValue</a> :: Int <a href="#v:maxValue" class="selflink">#</a></p><div class="doc"><p>The maximum value of an integer (is returned when there is no path from A to B)</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Memoization" class="def">Memoization</a> = Map <a href="Types.html#t:Coords" title="Types">Coords</a> ([Set <a href="Types.html#t:Coords" title="Types">Coords</a>], Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int)) <a href="#t:Memoization" class="selflink">#</a></p><div class="doc"><p>Stores the distance from every point to every other point</p></div></div><div class="top"><p class="src"><a id="v:distance" class="def">distance</a> <a href="#v:distance" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>the given mamoization</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the first point</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the second point</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>the distance between them, or maxValue if there is no path from one to the other</p></td></tr></table></div><div class="doc"><p>Given a Memoization, extracts from it the distance between 2 points</p></div></div><div class="top"><p class="src"><a id="v:mazeSize" class="def">mazeSize</a> <a href="#v:mazeSize" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>the given Mamoization object</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the size of the original maze (height, width)</p></td></tr></table></div><div class="doc"><p>Given a Memoization, returns the size of the original maze</p></div></div><div class="top"><p class="src"><a id="v:getMemory" class="def">getMemory</a> <a href="#v:getMemory" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the given maze</p></td></tr><tr><td class="src">-&gt; <a href="LazyBFS.html#t:Memoization" title="LazyBFS">Memoization</a></td><td class="doc"><p>the resulting Memoization object</p></td></tr></table></div><div class="doc"><p>Given a maze, creates a Memoization object storing the distance between every 2 points</p></div></div><div class="top"><p class="src"><a id="v:mapper" class="def">mapper</a> <a href="#v:mapper" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the maze</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the key</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>the original value (unused)</p></td></tr><tr><td class="src">-&gt; ([Set <a href="Types.html#t:Coords" title="Types">Coords</a>], Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int))</td><td class="doc"><p>the resulting data structure</p></td></tr></table></div><div class="doc"><p>Populates an empty entry with the intended data structure using the key</p></div></div><div class="top"><p class="src"><a id="v:coords" class="def">coords</a> <a href="#v:coords" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the original maze (used for size)</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the given point</p></td></tr><tr><td class="src">-&gt; Map <a href="Types.html#t:Coords" title="Types">Coords</a> (Maybe Int)</td><td class="doc"><p>The map of points</p></td></tr></table></div><div class="doc"><p>Returns a Map containing every point bigger than the given point.
   Used to ensure no 2 pairs of points in the final map are equivalent.</p></div></div><div class="top"><p class="src"><a id="v:atDists" class="def">atDists</a> <a href="#v:atDists" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the given maze</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the source point</p></td></tr><tr><td class="src">-&gt; [Set <a href="Types.html#t:Coords" title="Types">Coords</a>]</td><td class="doc"><p>the list of sets</p></td></tr></table></div><div class="doc"><p>Given a maze and a source point, returns a list of Sets, where the <em>n</em>-th Set
   contains all the points of the maze distanced <em>n</em> from the source</p></div></div><div class="top"><p class="src"><a id="v:atDists-39-" class="def">atDists'</a> <a href="#v:atDists-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the given maze</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the source point</p></td></tr><tr><td class="src">-&gt; Set <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the set before the previous</p></td></tr><tr><td class="src">-&gt; Set <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the previous set</p></td></tr><tr><td class="src">-&gt; [Set <a href="Types.html#t:Coords" title="Types">Coords</a>]</td><td class="doc"><p>the list of sets</p></td></tr></table></div><div class="doc"><p>Auxiliar function to atDists. Recursively creates the list of Sets from the 2 previous sets</p></div></div><div class="top"><p class="src"><a id="v:getNeighbours" class="def">getNeighbours</a> <a href="#v:getNeighbours" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>the given maze</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Coords" title="Types">Coords</a></td><td class="doc"><p>the source point</p></td></tr><tr><td class="src">-&gt; [<a href="Types.html#t:Coords" title="Types">Coords</a>]</td><td class="doc"><p>the adjacent points</p></td></tr></table></div><div class="doc"><p>Given a maze and a source point, returns the adjacent points to the source
   that are clear (for definition of &quot;clear&quot;, check PacmanUtils.isSquareClear)</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>