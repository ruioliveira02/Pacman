<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tarefa3</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Introdu&#231;&#227;o</h1><p>Foi pedido, ap&#243;s a gera&#231;&#227;o autom&#225;tica de labirintos da <a href="Tarefa1.html">Tarefa1</a>, que se obtivesse
    uma forma de compactar o labirinto, aproveitando a repeti&#231;&#227;o de elementos.</p><p>A solu&#231;&#227;o para o problema que se pretende resolver &#233; simples e n&#227;o provocou dificuldade
    ou constrangimento.</p><h1>Objetivo</h1><p>O objetivo desta tarefa &#233; comprimir um labirinto do Pacman, de forma a este poder
    ser representado atrav&#233;s de uma menor quantidade de dados. Para isso, aproveita-se
    a repeti&#231;&#227;o sucessiva de v&#225;rias pe&#231;as (nomeadamente paredes) nos labirintos.</p><h1>Solu&#231;&#227;o</h1><p>Primeiro, come&#231;a-se por compactar todas as filas individualmente. Para isso, percorre-se cada fila,
    tendo em conta a pe&#231;a encontrada anteriormente. Quando se encontra uma pe&#231;a diferente, adiciona-se
    o par com essa pe&#231;a e o n&#250;mero de vezes que aparece &#224; fila compactada, repetindo o processo para o
    resto da fila, at&#233; esta ser vazia.</p><p>Finalmente, procuram-se por elementos repetidos no labirinto compactado. Para fazer isso, percorre-se
    a lista. Para cada elemento da lista, percorre-se a lista novamente, procurando por elementos iguais a
    este, substituindo-os pelo construtor <code><a href="Types.html#v:Repeat" title="Types">Repeat</a></code>.</p><h1>Conclus&#227;o</h1><p>Obteve-se assim um labirinto compactado. O grupo considera que esta tarefa n&#227;o colocou qualquer
    dificuldade, sendo, por isso, a mais simples de todo o projeto.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:partitionCorridor">partitionCorridor</a> :: <a href="Types.html#t:Piece" title="Types">Piece</a> -&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; (Int, <a href="Types.html#t:Corridor" title="Types">Corridor</a>)</li><li class="src short"><a href="#v:compactCorridor">compactCorridor</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li><li class="src short"><a href="#v:removeEqualInstructions">removeEqualInstructions</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:removeEqualInstructionsAux">removeEqualInstructionsAux</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; Int -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:removeInstructionsEqualTo">removeInstructionsEqualTo</a> :: (<a href="Types.html#t:Instruction" title="Types">Instruction</a>, Int) -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:compactMaze">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:partitionCorridor" class="def">partitionCorridor</a> <a href="#v:partitionCorridor" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Piece" title="Types">Piece</a></td><td class="doc"><p>The piece to compare the others against</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a></td><td class="doc"><p>The given corridor</p></td></tr><tr><td class="src">-&gt; (Int, <a href="Types.html#t:Corridor" title="Types">Corridor</a>)</td><td class="doc"><p>A tuple consisting of the number of consecutives elements in corridor equal to the given piece, and the remaining corridor</p></td></tr></table></div><div class="doc"><p>Partitions a corridor based on a given piece. It returns a tuple, representing the number of consecutive elements in the beggining of the list equal to 
 the given piece, and the remaining list, i.e., the corridor starting at the first element different than the given piece. 
 It works in the same way as the span function, only that the first element it returns is an Int corresponding to the length of the list instead of the
actual list</p><h2><em>Examples</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>partitionCorridor Wall [Wall, Wall, Empty, Food Little, Food Little]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(2,[ ,.,.])
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>partitionCorridor Empty [Empty, Food Little, Wall, Empty]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,[.,#, ])
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:compactCorridor" class="def">compactCorridor</a> <a href="#v:compactCorridor" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Corridor" title="Types">Corridor</a></td><td class="doc"><p>The uncompressed corridor</p></td></tr><tr><td class="src">-&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</td><td class="doc"><p>The compressed corridor, as a list of (Int, Piece) and not an Instruction</p></td></tr></table></div><div class="doc"><p>Compacts a corridor to a list of '(Int, Piece)', but not into an <code><a href="Types.html#t:Instruction" title="Types">Instruction</a></code></p><h2><em>Examples</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>compactCorridor [Wall, Wall, Empty, Food Little, Food Little]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[(2,#),(1, ),(2,.)]
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>compactCorridor [Empty, Empty, Food Little, Wall, Empty]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[(2, ),(1,.),(1,#),(1, )]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:removeEqualInstructions" class="def">removeEqualInstructions</a> <a href="#v:removeEqualInstructions" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The original set of instructions</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The compressed set of instructions</p></td></tr></table></div><div class="doc"><p>Replaces all identical instructions with a Repeat instruction</p><h2><em>Examples</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEqualInstructions [Instruct [(1,Wall), (2, Empty)], Instruct [(3,Empty)], Instruct [(3,Empty)]]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Instruct [(1,#),(2, )],Instruct [(3, )],Repeat 1]
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEqualInstructions [Instruct [(2,Wall), (2, Empty)], Instruct [(3,Empty)], Instruct [(4,Empty)], Instruct [(2,Wall), (2, Empty)], Instruct [(2,Wall), (2,Empty)]]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Instruct [(2,#),(2, )],Instruct [(3, )],Instruct [(4, )],Repeat 0,Repeat 0]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:removeEqualInstructionsAux" class="def">removeEqualInstructionsAux</a> <a href="#v:removeEqualInstructionsAux" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The original set of instructions</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>The index of the current head of the list</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The new compressed set of instructions</p></td></tr></table></div><div class="doc"><p>Auxiliary function to <code><a href="Tarefa3.html#v:removeEqualInstructions" title="Tarefa3">removeEqualInstructions</a></code>.
   This function uses an accumulator to know what is the index of the head of the list,
   in order to feed it to the <code><a href="Tarefa3.html#v:removeInstructionsEqualTo" title="Tarefa3">removeInstructionsEqualTo</a></code>, as it requires the index value</p><h2><em>Example</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEqualInstructionsAux [Instruct [(1,Wall), (2, Empty)], Instruct [(3,Empty)], Instruct [(3,Empty)]] 0
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Instruct [(1,#),(2, )],Instruct [(3, )],Repeat 1]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:removeInstructionsEqualTo" class="def">removeInstructionsEqualTo</a> <a href="#v:removeInstructionsEqualTo" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Types.html#t:Instruction" title="Types">Instruction</a>, Int)</td><td class="doc"><p>The instruction to compare the others against, and its respective index</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The original set of instructions</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The new set of instructions with all instances of the given instruction replaced with 'Repeat i'</p></td></tr></table></div><div class="doc"><p>Replaces all <code><a href="Types.html#t:Instruction" title="Types">Instruction</a></code> equal to the given <code><a href="Types.html#t:Instruction" title="Types">Instruction</a></code> with a <code><a href="Types.html#v:Repeat" title="Types">Repeat</a></code> <code><a href="Types.html#t:Instruction" title="Types">Instruction</a></code></p><h2><em>Example</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeInstructionsEqualTo (Instruct [(3, Empty)], 0) [Instruct [(1,Wall), (2, Empty)], Instruct [(3,Empty)], Instruct [(3,Empty)]]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Instruct [(1,#),(2, )],Repeat 0,Repeat 0]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:compactMaze" class="def">compactMaze</a> <a href="#v:compactMaze" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Types.html#t:Maze" title="Types">Maze</a></td><td class="doc"><p>The given maze</p></td></tr><tr><td class="src">-&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></td><td class="doc"><p>The maze in instruction form</p></td></tr></table></div><div class="doc"><p>Compacts a maze into a set of instructions</p><h2><em>Example</em></h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>compactMaze testMaze -- consider testMaze the same as defined in Tarefa2.hs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Instruct [(8,#)],Instruct [(1, ),(1,*),(3,.),(1,M),(1,.),(1, )],Instruct [(1, ),(2,.),(1,&lt;),(1,.),(1,#),(1,.),(1, )],Repeat 0]
</code></strong></pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>